Need to know :
1. basics of js
2. basics of html
______________________________________________________________________________________________________________________________________

what is react : 
external lib that helps us create websites easier

-> external lib 
-> helps us create websites easier
    => feels natural ,lot simpler than using the dom featuere in js, create html elements we want directly then give it to react and react will display them
    => jsx lets us find the error easier -- because those are actual elemets rater than text/a string
    => we can insert values inside jsx elements ex :       const paragraph = <p>This is a paragraph {2+2}</p>;

______________________________________________________________________________________________________________________________________

why are there two external libs for react ?
<script src="https://unpkg.com/supersimpledev/react.js"></script>
<script src="https://unpkg.com/supersimpledev/react-dom.js"></script>

react can be used in different places 

websites - react(shared features), reactDOM
mobile apps - react(shared features), reactNative
______________________________________________________________________________________________________________________________________

lesson 2 : components , props , start the chatbot project

components -- just a piece of the website
when building websites : 
    - it's better to split up the websites into pieces.
    - so we can work on a small piece of the website at a time.
Main ideas of react : 
    => we can create our own html elements

{/* 3 ways to call a component */}
    1. {/* {ChatInput()} function call */}
    2. {/* <ChatInput></ChatInput> component syntax */}{/* we are creating our own html element , there are some default html elements in react like <div> , <p> , <span> , <input> , <button>  but here we created our own html element <ChatInput /> */}
    3. {/* <ChatInput /> */} {/* self closing tag */}

fragment (<></> = group elements together without creating an extra <div>)

components are designed to be reusable.

PROPS (properties) : 
        -->every component function gets one parameter up here called props. 
        -->props is an object and it contains all the attributes that we give this component.
        -->props are useful because they make our components reusable.

if statements inside the jsx : 
// guard operator &&
// const result = value1 && value2: if value1 is true then result will be value2 , this works jsut like an if-statement

now insted of using a variable to save our app best practice is to create a componnent to save this app
why because it gives us extra features of components like props etc 
and also notice we can have components inside the components this lets us split our website smaller and smaller pieces.

______________________________________________________________________________________________________________________________________
lesson 3 : state , event handlers , create the chatbot features

______________________________________________________________________________________________________________________________________
lesson 4 : css with react, hooks, finish the chatbot project

css = change the appearence of the website
css with react = use css how you do normally
way 1 : create a style element

in react we use className
    -- react is js code
    -- js already has a feature called className
    -- class is a reserved word so we use className

autoscroll :
    ->we will use hooks , hooks = insert react features into our component
    
    useState =>
    ->React.useState is a hook , const[inputText,setInputText]=React.useState(''); it inserts a react feature called state into our component
    -->and state automatically udpates the html when the data changes
    --> some other hooks example : useStatee(), useEffect(), useRef() and more... , every hook starts with the name use
    
    useEffect =>
    --> useEffect = let's run some code after the component is created or updated
    --> put hooks at the top of the component , it should not be inside of anything like if statement or function that is wrong
    --> react will run this function of useEffect - after component is created or every time the component is updated.
    
    useRef =>
    --> useRef automatically save an HTML element from the component
    --> ref = container with special react features
    --> one special feature is we can give this ref to react and react will automatically save an html elemnt inside this ref or inside this container.

    custom hooks =>
    --> in addition to built-in hooks like useState and useEffect , we can also create our own , custom hooks. so we can easily add this feature to other components.
    

______________________________________________________________________________________________________________________________________

lesson5 : proper React setup with vite;

-->install node and npm , check via npm -v and node -v commands
--> node -- let us run the js files outside of a browswer
--> npm - node package manager , package = external lib , node lets us install external libs or packages in our project
--> install supersimpledev by npm install supersimpledev , you will see in node_modules/supersimpledev
--> some of the npm packages also add a command to our command line ex : create-vite , it also adds a command create-vite for our command line , create-vite helps us set up new react project
--> install the create-vite package , run create-vite in the command line => more better option use npx create-vite (npx does both thnings , x means execute) or you can also use npm create vite( this is a shortcut for npx create-vite)

project structure:
-->src = source folder - contains code for our webiste (all js and css code goes in here , remember when writing react code we write jsx instad of js code so file here also ends with .jsx)
--> assets = contains images we wnat in our project
--> public = contains files that should be available to the public (we can access these using a URL)
--> .gitignore , actually this is part of git , git lets us track the changes in our code , for this project we are learning react so this is irrelevant
--> eslint.config.js - used by tool called eslint -- eslint highlights problems in our js code -- to use eslint we can install eslint extension => now this files eslint config files configures the eslint , it tells eslint what to check for 
--> / -- contains all the html code for our react website (this is where we were making changes till previous lessons like chatbot.html and all ) but here we don't need to write js code here , it loads the js from a different file
--> package-lock.json - it says the version numbers of all the packages that we installed (even those that are not in package.json) , next time we run npm install this ensures we get the same versions
--> package.json - has lists of packages that we need to install to run this project
--> readme.md -- for informational purpose
--> vite.config.js -- vite = tool that we used to set up this project , it also helps us build the website , vite also creates a server (a server puts our webiste at a URL) , vite server also like live server refreshes the webiste when we change the code
                   -- this config file configures vite .

let;s us move the previous chatbot project in this new one

main.jsx does the same things as we have done in our html files so far which is : 
-- we do createRoot give it a container and render the app component , the same thing is happening in main.jsx go check it.
const container = document.querySelector('.js-container');
ReactDOM.createRoot(container).render(<App />);

<StrickMode> = gives us some additoinal checks and warnings when developing our app

why index.css and app.css two different css files ?
best practice is to split our css into different files.

App.css - all the css for app component goes to the app.css
index.css - all the css for overall website goes to index.css

big advantage -- separate our code into different files
best practice =>now separate each component into its each file -- easy to manage

javascript moduel review : 
    ->ChatInput for example only exists in this file ChatInput.jsx , it cannot be used outside the file.
    -> if we wnat to use outside the file we need to export it 

commands : 
npm run dev works how : 
    npm run : tells the computer to look inside package.json for a section called scripts
    dev : look inside scripts for dev and run the command on the right side (which is vite)
    the vite command is added by the vite package. it starts the vite server , which lets us view the react website

next npm run lint :
    this runs the command eslint, which checks our files and gives a list of eslint errors. by default , there are no errors.

______________________________________________________________________________________________________________________________________
lesson 6 : routing, git , start the ecommerce project

git = helps us track our changes in the code
.gitignore = tells git which fiels and folders to ignore (not to track changes)

web page is a single page like home page , login page 
a website is a group of web pages 

routing : it lets us create multiple pages in react
routings lets us create multiple pages using 1 html file , this let us reuse our html code

REACT ROUTER : read documentaion for react-router if you want more knowledge
-->we need to load it where we render the app component like this : <BrowserRouter> <App /> </BrowserRouter>
-->inside our App component we need to add a component called routes  
-->basic structure : <Route> adds a page to our webiste , path tells the path of this page, element tells which element or component to display
    <Routes>
      <Route path="/" element={<HomePage />} />
      <Route path="checkout" element={<CheckOutPage>} />
    </Routes>
--> so routing is really simple , one more thing we are only using one index file ehre / file so this index file is shared between all the pages , reduces repitions
--> this is a single page application (SPA) => we only have one html file and we use react to create multiple pages 
--> shortcuts with react router : 
    1. insted of path="/" we can use index both are same

--> shared components we usually put in a folder called components and in pages we will keep all the pages we are using for our website
--> usually Link elements <a> reload the page if we go to another page using those , this made sense if we had multiple html compnents like earlier but now we are using react and only one index.html we are using , we can use javascript to do this and use <Link> instead of <a>
    so when using react-router we should use <Link> instead of <a> , it go to another page without reloading


<NavLink> instead of <Link> : 
special feature of <NavLink> is it knows which page is loaded. ex : if you are on the orders page , it adds a class active to the orders link (className = "order-link ... active")

______________________________________________________________________________________________________________________________________
lesson 7 : backend , data fetching , async await

backend : 
-->manages the data
-->shares data between computers
-->backend can also run on the smae computer as the frontend(this is what we are doing right now on localhost) but once it is on the internet it will be another computer most likely

examples and explanations => 
so a real life ecommerce website might have hundreds of thousands of products and it doesn't make sense to have it in our computer/or client's computer , might not have enough space also 
company's computer -- saves all products, when we visit the site this computer sends ony the product we need , this computer which company uses is called backend and bakend manages all the data.
another exmaple/uses : we add something in cart , it doens't make sense to save it in our/customer computer because if we visit from another website the cart will be lost. so we save the cart in backend as well , so backend let;s us share data between the computers also.


learning in this lesson : 
1. how to add a backend
2. how to use the backend

now how to fetch data using fetch (js featuere):

// asynchronous code = code that doesn't finish right away, below line is an example of asynchronous code
  // fetch() returns a promise, promise = lets us wait for asynchronous code to finish , so we use method of promise called .then() which runs a function when the asynchronous code is done
  // fetch('http://localhost:3000/api/products')
  //   .then((response)=>{
  //     response.json().then((data)=>{
  //       console.log(data);
  //     }); // resopnse.json() gives us the data that is attached to the response , now response.json() is also asynchronous code => a promise , so need to use another .then() to get the data
  //   })

  // now instead of doing nested .then() we can use return response.json() and chain another .then() to the first .then() , this is called promise chaining
  fetch('http://localhost:3000/api/products')
    .then((response)=>{
      return response.json()
    })
    .then((data)=>{
      console.log(data);
    });

now this is still tricky and can be confusing so we will use npm package axios , => cleaner way to make requests to the backend

/api/products -- gives products data
/api/cart-data -- gives cart data for our application
whoever creates the backend decides what the URL paths will be ,common naming convention is GET/api/
https://github.com/SuperSimpleDev/react-course/blob/main/1-links.md => here you can find the documentaion for the backend for e-commerce webiste that we are creating
api => application programming interface , /api = these URL paths are for interacting with the backend

we should not use localhost:3000 everytime so config it in vite.config.js 
and also images : 
server: {
    proxy: {
      '/api': {
        target: "http://localhost:3000",
      },
      '/images': {
        target: "http://localhost:3000",
      }
    }
}
and this in index.html for images : 
<base href="/" />
so that images will be taken from backend like /images/ this format 


Async await = lets us write asynchronous code like normal code ( that runs line by line) => easier to understand => in react it's recommended that we use async await instead of promises when we can however there is a small problem when using async await and useEffect => discussing this below.
right now we are using promises that means we need to use .then() to wait for that promise or code to finish and then run this function 
but with async await =>  we can write this like a normal code 

so instead of this : 

useEffect(() => {
  await axios.get('/api/products')
    .then((response)=>{
    setProducts(response.data);
  });
},[]);

we can write it like this : (we are waiting for response so no need to do .then() because we were doing the same thing there also)

useEffect(async () => {
  const response = await axios.get('/api/products');
  setProducts(response.data);
}, []);

-------problem in useEffect and async await---------- : 
when we put async in front of a function , this fn will now return a promise because we are waiting for response due to await right ?
that means this entire fn will take some time to finish , thats why it has to return a promise

problem is inner fn in useEffect should not return a promise
it should only return nothing or a cleanup fn like : 

useEffect(()=>{
  window.addEventListener('scroll',()=>{

  });
  
  return () => {
   window.removeEventListener('scroll');
  }
})

return () => {
  window.removeEventListener('scroll');
}
this is a cleanup fn , cleanup fn is useful if you want to do some cleanup once this component is used.

useEffect(async () => {
  const response = await axios.get('/api/products');
  setProducts(response.data);
}, []);
so our current code is sort of breaking the rules of useEffect , to solve this we create a new fn inside useEffect like this : 
--> create a new fn inside the return fn , use async await there and then run that fn , problem solved.
useEffect(() => {
  const getHomeData = async () => {
    const response = await axios.get('/api/products');
    setProducts(response.data);
  };
  
  getHomeData();
}, []);

hook useParam : 
useParams returns an object with the dynamic route params (e.g. { orderId, productId }) from the current URL.
Developers use it to read IDs/slugs from the URL so the component can fetch data or change UI based on that route.



______________________________________________________________________________________________________________________________________
lesson 8 : data mutation = udpate data in the backend  , types of requests 

we will learn to update data (as we were only getting the data till now) from backend
we will also learn add products to our cart and order 

axios.get('api/cart-items') = get data from backend
.post() = create data in the backend => request body : here we also need to give extra information like which product to add to the cart for our current application if we click on add to cart

.post() => we send url path , based on url path , the backend can do different things
for ex : if we do /api/product = gives us the products
         if we do /api/cart-iterms = gives us the cart 
every request also has a type like get() = sends get and /api/cart-items (sends 2 pieces of info), post() = this sends type:post and url path : /api/cart-items ,
when backend recieves the type , it looks both at the type and the url path and decides what to do 

get => get the cart items
post => create a new cart item

type is also called a http method , 4 common types of requests : 
  get = get some data
  post = create some data
  put = update some data
  delete = delete some data
axios has a method for each type.

now inside the checkout page for each product we have delivery option we will try to update them , now we are updating something so this is the type of put request 
PUT request 

Another hook : useNavigate 
so for our project let's say we placed an order by using place your order button then what if we go to orders page after clicking it to see our orders , for this useNavigate hook will be useful.
  const navigate = useNavigate();
lets us navigate to (go to ) another page in our app by using like navigate(/orders) or some url 


window.axois = axios ; learning about this and what does this do : 
// This makes axios available in the Console.
// - Then, you can try running axios.post('/api/reset') in the Console.

// More details:
// - Normally, we can't access values (like axios) outside of a file.
// - However, JavaScript has a built-in, global object called window
//   (this represents the browser window).
// - So one way to make a value accessible anywhere (including in the
//   Console), is to attach it to the window object. That's why we
//   do window.axios = axios;
// - Now, in the Console, we can run window.axios.post(...)
// - And JavaScript has another shortcut we can use. If we just type
//   "axios", this is a shortcut for "window.axios"
// - That's why the code window.axios = axios; lets us use "axios"
//   anywhere (including in the Conosle).


______________________________________________________________________________________________________________________________________
lesson 9: automated tests in react
npm packages for automated testing (two most popular): 
-jest 
-vitest (going to use this bcoz it integrates with vite well) (but both are reallly similar)

--save-dev means only for developement

different type of tests ; 
unit test => test 1 unit (or 1 piece) of the code
like formatMoney fn from money.js will be considered unit test
testing components like product.jsx is not unit test because they use different pieces of code together
npm install --save-dev vitest@3.1.2

integration test => test multiple units of code working together
when testing a function we run a fn and we check the result
but when testing a component we render the component and check the result , redner => display the component on the page
to render the component we need some more packages 
npm install --save-dev @testing-library/react@16.3.0 @testing-library/jest-dom@6.6.3 @testing-library/user-event@14.6.1 jsdom@26.1.0

also need to create some config files to test our components

next test user interactions like add to cart button

till now we have learnt to mock that doesn't do anything
now we are gonna learn mock the impelementaion = make the mock do whatever we want 

______________________________________________________________________________________________________________________________________
lesson 9 : deploying to aws 

service 1 : EC2 amazon elastic compute cloud (EC2)
EC2 = rent a computer from AWS
now we could buy a physical computer ourselves to host backend , but need to run this 24/7 , that's lot of work , so we use cloud services
so EC2 = lets us rent a computer from aws , this is called infrastructure as a service (Iaas)

EC2 just gives us a computer : 
we still need to , install nodejs and connect it to the internet, upload our code 

to solve this aws provides another service : elastic beanstalk
you can think elastic beanstalk as a layer above ec2 and other services , it uses EC2 to rent a computer but also installs all the software we need 
elastic beanstalk => also does all teh software setup for us. all we need to do is upload our code there. this is called platform as a service (Paas)
==>after doing some configuration it will ask for role . role = gives elastic beanstalk permission to use other services in AWS
==> instance types => lets us choose the size of the computer to rent from ec2

elastic beanstalk is goign to : 
  1. rent a computer using ec2
  2. install nodejs and npm 
  3. connect to the internet

now that we have our own computer we need to put backend and frontend on the internet. 
first we will put the backend.
  we need to uplod it as a zip file . => npm run zip is the command for this we have already configured , get the zip file and upload it now.
now let's put our frontend on the internet.
  for this run npm run build ==> shortcut for vite build (refer package.json for these commands and how it works)
  so now you will see dist folder : 
    here there is index.html => html for our react website
    assets folder -> js file , this is all our react code converted into normal js code (because browser only understands this) , also it minified (compressed) the code (shortened the var names and removed the extra spaces), because browser needst to download all the frontend code and run it , by minifing it makes our code run faster.
    assets folder -> css file , same thing minified version

so when we open the website , we need to download this react code from somewhere : 
  there are two options : 
  1. we can put it in github repo and use it from there 
  2. or we alerady have one elastic beanstalk so use that.(backend computer). this simplifies the setup , we only need to setup one computer
      -> so push this dist folder in backend code , i have added some code in ecommerce-backend so it works with this dist foler.
      -> do another zip using npm run zip and upload this to elastic beanstalk

_______so what is happening_______ : 
first we put our backend on internet so backend is running
now we put our frontend in the backend code.we setup some code in backend so when we visit the website using URL path : / , backend sends the react code to our computer
now we have the react code running on our computer and it communicates with backend running on another computer(elastic beanstalk)
so this is how a real world react app works.

when developing : 
we run frontend (port 3000) and backend (port 5173) on the same computer because it is easier.
but when we put it on the internet , fronend code runs on our computer and backend runs on another (elastic beanstalk in this case.)

now we can add a shortcut to make this process a little easier , 
insted of manually putting dist folder to backend folder everytime we can maket this easier using vite.config.js file
this saves us time.

_________now how to deploy react without a backend.
if a react app doesn't have a backend , we can put the code on the internet directly.
so try to deploy chatbot project for now then
we can put this chatbot-project to any website that puts html website to the internet , like github pages. no backend knowledge required.

____more config on aws side 
change configuration->instance traffic and scaling -> capcity = load balanced
load balancer => it adds another computer in front of our backend computer , this is called a load balancer.
what does load balancer does -> if we have a really busy website , one computer might not be enough to handl all the requests
so we can actually runt he bcakend on multiple computers and this load balancer will distribute this request across these computers , this allows the website to handle much more users.


currently all our data like cart, order ,products all are saved in db in a file called database.sqlite
in real world we put the database in anotehr computer , it lets us share the data between multiple backend computers
so for this go to network and databse -> enable database toggle on -> add mysql and db.t3.micro 5gb , set password
we alredy have some code in backend to connect to this database. so it should just work.
so now the setup is like this : 

out computer (runs frontend ) -> elastic beanstalk(load balancer + backend + database)

set up a domain name now because the default is too long.
domain name is like (mywebsite.com or youtube.com) = short name that makes it easy to access our website.

purchase a domain name. 10$ or something.
you can buy it from namecheap.com
maybe purchase something like .com or .net because some doesn't work with normal browsers.

setup the domain name in aws : route53 => manage our domain name in aws. click get started => click create hosted zones. => click get started. or go to hosted zones => create hosted zones (either works)
currently it costs about 0.016$/day , can use it for free for few hours

after clicking create hosted zones you will see => create record => configure your application by filling the information (toggle alias , do elastic beanstalk , region fill , take your app.)
in namecheap => domain list , verify email, login again, ope manage , go to nameservers , click on custom dns in dropdown. 
go back to hosted zones , you will see records in there see type NS (nameserver) select nameservers from there and copy it in nameservers in namecheap
what this does is when we open the website namecheap is going to redirect to aws and then aws is going to elastic beanstalk or our app.

after this you can go to http://yourwebsite.com
not secure because of http => our website is not using encryption , for this to go away we need to setup ssl encryption 
go to aws , search certificate manager -> request certificate -> fill domain name -> click request -> pending validation , click records in route 53 , click create records

go to elastic beanstalk , instance traffic settings , edit -> add listener -> port 443 , protocol - https = secure connection => tjis jsut adds ssl certificate to load balancer so now any data sent to our website will be encrypted so go down click apply 
now go to : https://yourwebsite.com not secure warning will be gone , you can also go to yourwebsite.com url directly also now.

________how to delete the website compeltely : 
so to delete it ; go to ecommerce-project-react-env , click actions -> terminate environment

if you have done it for your website (for me i didin't do it) :
after that go to route53 -> hosted zones -> click a record and cname record and delete records
and then delete the hosted zones at top 

go to certificate manager :
lsit certificate : select it and type delte and click delete

you can delete your entire account with ; click profile -- account -> close account -> after free tier passes you might wnat to do it.
