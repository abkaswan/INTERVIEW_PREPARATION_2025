Need to know :
1. basics of js
2. basics of html
______________________________________________________________________________________________________________________________________

what is react : 
external lib that helps us create websites easier

-> external lib 
-> helps us create websites easier
    => feels natural ,lot simpler than using the dom featuere in js, create html elements we want directly then give it to react and react will display them
    => jsx lets us find the error easier -- because those are actual elemets rater than text/a string
    => we can insert values inside jsx elements ex :       const paragraph = <p>This is a paragraph {2+2}</p>;

______________________________________________________________________________________________________________________________________

why are there two external libs for react ?
<script src="https://unpkg.com/supersimpledev/react.js"></script>
<script src="https://unpkg.com/supersimpledev/react-dom.js"></script>

react can be used in different places 

websites - react(shared features), reactDOM
mobile apps - react(shared features), reactNative
______________________________________________________________________________________________________________________________________

lesson 2 : components , props , start the chatbot project

components -- just a piece of the website
when building websites : 
    - it's better to split up the websites into pieces.
    - so we can work on a small piece of the website at a time.
Main ideas of react : 
    => we can create our own html elements

{/* 3 ways to call a component */}
    1. {/* {ChatInput()} function call */}
    2. {/* <ChatInput></ChatInput> component syntax */}{/* we are creating our own html element , there are some default html elements in react like <div> , <p> , <span> , <input> , <button>  but here we created our own html element <ChatInput /> */}
    3. {/* <ChatInput /> */} {/* self closing tag */}

fragment (<></> = group elements together without creating an extra <div>)

components are designed to be reusable.

PROPS (properties) : 
        -->every component function gets one parameter up here called props. 
        -->props is an object and it contains all the attributes that we give this component.
        -->props are useful because they make our components reusable.

if statements inside the jsx : 
// guard operator &&
// const result = value1 && value2: if value1 is true then result will be value2 , this works jsut like an if-statement

now insted of using a variable to save our app best practice is to create a componnent to save this app
why because it gives us extra features of components like props etc 
and also notice we can have components inside the components this lets us split our website smaller and smaller pieces.

______________________________________________________________________________________________________________________________________
lesson 3 : state , event handlers , create the chatbot features

______________________________________________________________________________________________________________________________________
lesson 4 : css with react, hooks, finish the chatbot project

css = change the appearence of the website
css with react = use css how you do normally
way 1 : create a style element

in react we use className
    -- react is js code
    -- js already has a feature called className
    -- class is a reserved word so we use className

autoscroll :
    ->we will use hooks , hooks = insert react features into our component
    
    useState =>
    ->React.useState is a hook , const[inputText,setInputText]=React.useState(''); it inserts a react feature called state into our component
    -->and state automatically udpates the html when the data changes
    --> some other hooks example : useStatee(), useEffect(), useRef() and more... , every hook starts with the name use
    
    useEffect =>
    --> useEffect = let's run some code after the component is created or updated
    --> put hooks at the top of the component , it should not be inside of anything like if statement or function that is wrong
    --> react will run this function of useEffect - after component is created or every time the component is updated.
    
    useRef =>
    --> useRef automatically save an HTML element from the component
    --> ref = container with special react features
    --> one special feature is we can give this ref to react and react will automatically save an html elemnt inside this ref or inside this container.

    custom hooks =>
    --> in addition to built-in hooks like useState and useEffect , we can also create our own , custom hooks. so we can easily add this feature to other components.
    

______________________________________________________________________________________________________________________________________

lesson5 : proper React setup with vite;

-->install node and npm , check via npm -v and node -v commands
--> node -- let us run the js files outside of a browswer
--> npm - node package manager , package = external lib , node lets us install external libs or packages in our project
--> install supersimpledev by npm install supersimpledev , you will see in node_modules/supersimpledev
--> some of the npm packages also add a command to our command line ex : create-vite , it also adds a command create-vite for our command line , create-vite helps us set up new react project
--> install the create-vite package , run create-vite in the command line => more better option use npx create-vite (npx does both thnings , x means execute) or you can also use npm create vite( this is a shortcut for npx create-vite)

project structure:
-->src = source folder - contains code for our webiste (all js and css code goes in here , remember when writing react code we write jsx instad of js code so file here also ends with .jsx)
--> assets = contains images we wnat in our project
--> public = contains files that should be available to the public (we can access these using a URL)
--> .gitignore , actually this is part of git , git lets us track the changes in our code , for this project we are learning react so this is irrelevant
--> eslint.config.js - used by tool called eslint -- eslint highlights problems in our js code -- to use eslint we can install eslint extension => now this files eslint config files configures the eslint , it tells eslint what to check for 
--> / -- contains all the html code for our react website (this is where we were making changes till previous lessons like chatbot.html and all ) but here we don't need to write js code here , it loads the js from a different file
--> package-lock.json - it says the version numbers of all the packages that we installed (even those that are not in package.json) , next time we run npm install this ensures we get the same versions
--> package.json - has lists of packages that we need to install to run this project
--> readme.md -- for informational purpose
--> vite.config.js -- vite = tool that we used to set up this project , it also helps us build the website , vite also creates a server (a server puts our webiste at a URL) , vite server also like live server refreshes the webiste when we change the code
                   -- this config file configures vite .

let;s us move the previous chatbot project in this new one

main.jsx does the same things as we have done in our html files so far which is : 
-- we do createRoot give it a container and render the app component , the same thing is happening in main.jsx go check it.
const container = document.querySelector('.js-container');
ReactDOM.createRoot(container).render(<App />);

<StrickMode> = gives us some additoinal checks and warnings when developing our app

why index.css and app.css two different css files ?
best practice is to split our css into different files.

App.css - all the css for app component goes to the app.css
index.css - all the css for overall website goes to index.css

big advantage -- separate our code into different files
best practice =>now separate each component into its each file -- easy to manage

javascript moduel review : 
    ->ChatInput for example only exists in this file ChatInput.jsx , it cannot be used outside the file.
    -> if we wnat to use outside the file we need to export it 

commands : 
npm run dev works how : 
    npm run : tells the computer to look inside package.json for a section called scripts
    dev : look inside scripts for dev and run the command on the right side (which is vite)
    the vite command is added by the vite package. it starts the vite server , which lets us view the react website

next npm run lint :
    this runs the command eslint, which checks our files and gives a list of eslint errors. by default , there are no errors.

______________________________________________________________________________________________________________________________________
lesson 6 : routing, git , start the ecommerce project

git = helps us track our changes in the code
.gitignore = tells git which fiels and folders to ignore (not to track changes)

web page is a single page like home page , login page 
a website is a group of web pages 

routing : it lets us create multiple pages in react
routings lets us create multiple pages using 1 html file , this let us reuse our html code

REACT ROUTER : read documentaion for react-router if you want more knowledge
-->we need to load it where we render the app component like this : <BrowserRouter> <App /> </BrowserRouter>
-->inside our App component we need to add a component called routes  
-->basic structure : <Route> adds a page to our webiste , path tells the path of this page, element tells which element or component to display
    <Routes>
      <Route path="/" element={<HomePage />} />
      <Route path="checkout" element={<CheckOutPage>} />
    </Routes>
--> so routing is really simple , one more thing we are only using one index file ehre / file so this index file is shared between all the pages , reduces repitions
--> this is a single page application (SPA) => we only have one html file and we use react to create multiple pages 
--> shortcuts with react router : 
    1. insted of path="/" we can use index both are same

--> shared components we usually put in a folder called components and in pages we will keep all the pages we are using for our website
--> usually Link elements <a> reload the page if we go to another page using those , this made sense if we had multiple html compnents like earlier but now we are using react and only one index.html we are using , we can use javascript to do this and use <Link> instead of <a>
    so when using react-router we should use <Link> instead of <a> , it go to another page without reloading


<NavLink> instead of <Link> : 
special feature of <NavLink> is it knows which page is loaded. ex : if you are on the orders page , it adds a class active to the orders link (className = "order-link ... active")

______________________________________________________________________________________________________________________________________
lesson 7 : backend , data fetching , async await

backend : 
-->manages the data
-->shares data between computers
-->backend can also run on the smae computer as the frontend(this is what we are doing right now on localhost) but once it is on the internet it will be another computer most likely

examples and explanations => 
so a real life ecommerce website might have hundreds of thousands of products and it doesn't make sense to have it in our computer/or client's computer , might not have enough space also 
company's computer -- saves all products, when we visit the site this computer sends ony the product we need , this computer which company uses is called backend and bakend manages all the data.
another exmaple/uses : we add something in cart , it doens't make sense to save it in our/customer computer because if we visit from another website the cart will be lost. so we save the cart in backend as well , so backend let;s us share data between the computers also.


learning in this lesson : 
1. how to add a backend
2. how to use the backend

now how to fetch data using fetch (js featuere):

// asynchronous code = code that doesn't finish right away, below line is an example of asynchronous code
  // fetch() returns a promise, promise = lets us wait for asynchronous code to finish , so we use method of promise called .then() which runs a function when the asynchronous code is done
  // fetch('http://localhost:3000/api/products')
  //   .then((response)=>{
  //     response.json().then((data)=>{
  //       console.log(data);
  //     }); // resopnse.json() gives us the data that is attached to the response , now response.json() is also asynchronous code => a promise , so need to use another .then() to get the data
  //   })

  // now instead of doing nested .then() we can use return response.json() and chain another .then() to the first .then() , this is called promise chaining
  fetch('http://localhost:3000/api/products')
    .then((response)=>{
      return response.json()
    })
    .then((data)=>{
      console.log(data);
    });

now this is still tricky and can be confusing so we will use npm package axios , => cleaner way to make requests to the backend

/api/products -- gives products data
/api/cart-data -- gives cart data for our application
whoever creates the backend decides what the URL paths will be ,common naming convention is GET/api/
https://github.com/SuperSimpleDev/react-course/blob/main/1-links.md => here you can find the documentaion for the backend for e-commerce webiste that we are creating
api => application programming interface , /api = these URL paths are for interacting with the backend

we should not use localhost:3000 everytime so config it in vite.config.js 
and also images : 
server: {
    proxy: {
      '/api': {
        target: "http://localhost:3000",
      },
      '/images': {
        target: "http://localhost:3000",
      }
    }
}
and this in index.html for images : 
<base href="/" />
so that images will be taken from backend like /images/ this format 


Async await = lets us write asynchronous code like normal code ( that runs line by line) => easier to understand => in react it's recommended that we use async await instead of promises when we can however there is a small problem when using async await and useEffect => discussing this below.
right now we are using promises that means we need to use .then() to wait for that promise or code to finish and then run this function 
but with async await =>  we can write this like a normal code 

so instead of this : 

useEffect(() => {
  await axios.get('/api/products')
    .then((response)=>{
    setProducts(response.data);
  });
},[]);

we can write it like this : (we are waiting for response so no need to do .then() because we were doing the same thing there also)

useEffect(async () => {
  const response = await axios.get('/api/products');
  setProducts(response.data);
}, []);

-------problem in useEffect and async await---------- : 
when we put async in front of a function , this fn will now return a promise because we are waiting for response due to await right ?
that means this entire fn will take some time to finish , thats why it has to return a promise

problem is inner fn in useEffect should not return a promise
it should only return nothing or a cleanup fn like : 

useEffect(()=>{
  window.addEventListener('scroll',()=>{

  });
  
  return () => {
   window.removeEventListener('scroll');
  }
})

return () => {
  window.removeEventListener('scroll');
}
this is a cleanup fn , cleanup fn is useful if you want to do some cleanup once this component is used.

useEffect(async () => {
  const response = await axios.get('/api/products');
  setProducts(response.data);
}, []);
so our current code is sort of breaking the rules of useEffect , to solve this we create a new fn inside useEffect like this : 
--> create a new fn inside the return fn , use async await there and then run that fn , problem solved.
useEffect(() => {
  const getHomeData = async () => {
    const response = await axios.get('/api/products');
    setProducts(response.data);
  };
  
  getHomeData();
}, []);

hook useParam : 
useParams returns an object with the dynamic route params (e.g. { orderId, productId }) from the current URL.
Developers use it to read IDs/slugs from the URL so the component can fetch data or change UI based on that route.



______________________________________________________________________________________________________________________________________
lesson 8 : data mutation = udpate data in the backend  , types of requests 

we will learn to update data (as we were only getting the data till now) from backend
we will also learn add products to our cart and order 

axios.get('api/cart-items') = get data from backend
.post() = create data in the backend => request body : here we also need to give extra information like which product to add to the cart for our current application if we click on add to cart

.post() => we send url path , based on url path , the backend can do different things
for ex : if we do /api/product = gives us the products
         if we do /api/cart-iterms = gives us the cart 
every request also has a type like get() = sends get and /api/cart-items (sends 2 pieces of info), post() = this sends type:post and url path : /api/cart-items ,
when backend recieves the type , it looks both at the type and the url path and decides what to do 

get => get the cart items
post => create a new cart item

type is also called a http method , 4 common types of requests : 
  get = get some data
  post = create some data
  put = update some data
  delete = delete some data
axios has a method for each type.

now inside the checkout page for each product we have delivery option we will try to update them , now we are updating something so this is the type of put request 
PUT request 

Another hook : useNavigate 
so for our project let's say we placed an order by using place your order button then what if we go to orders page after clicking it to see our orders , for this useNavigate hook will be useful.
  const navigate = useNavigate();
lets us navigate to (go to ) another page in our app by using like navigate(/orders) or some url 


window.axois = axios ; learning about this and what does this do : 
// This makes axios available in the Console.
// - Then, you can try running axios.post('/api/reset') in the Console.

// More details:
// - Normally, we can't access values (like axios) outside of a file.
// - However, JavaScript has a built-in, global object called window
//   (this represents the browser window).
// - So one way to make a value accessible anywhere (including in the
//   Console), is to attach it to the window object. That's why we
//   do window.axios = axios;
// - Now, in the Console, we can run window.axios.post(...)
// - And JavaScript has another shortcut we can use. If we just type
//   "axios", this is a shortcut for "window.axios"
// - That's why the code window.axios = axios; lets us use "axios"
//   anywhere (including in the Conosle).


______________________________________________________________________________________________________________________________________
lesson 9: automated tests in react
npm packages for automated testing (two most popular): 
-jest 
-vitest (going to use this bcoz it integrates with vite well) (but both are reallly similar)

--save-dev means only for developement

different type of tests ; 
unit test => test 1 unit (or 1 piece) of the code
like formatMoney fn from money.js will be considered unit test
testing components like product.jsx is not unit test because they use different pieces of code together
npm install --save-dev vitest@3.1.2

integration test => test multiple units of code working together
when testing a function we run a fn and we check the result
but when testing a component we render the component and check the result , redner => display the component on the page
to render the component we need some more packages 
npm install --save-dev @testing-library/react@16.3.0 @testing-library/jest-dom@6.6.3 @testing-library/user-event@14.6.1 jsdom@26.1.0

also need to create some config files to test our components

next test user interactions like add to cart button

till now we have learnt to mock that doesn't do anything
now we are gonna learn mock the impelementaion = make the mock do whatever we want 