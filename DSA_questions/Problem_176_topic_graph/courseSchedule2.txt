https://leetcode.com/problems/course-schedule-ii/

210. Course Schedule II

There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.

    For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.

Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.

 

Example 1:

Input: numCourses = 2, prerequisites = [[1,0]]
Output: [0,1]
Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].

Example 2:

Input: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
Output: [0,2,1,3]
Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.
So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].

Example 3:

Input: numCourses = 1, prerequisites = []
Output: [0]

 

Constraints:

    1 <= numCourses <= 2000
    0 <= prerequisites.length <= numCourses * (numCourses - 1)
    prerequisites[i].length == 2
    0 <= ai, bi < numCourses
    ai != bi
    All the pairs [ai, bi] are distinct.




___________explantion on why we use three states for dfs here in directed graphs_____________
========================
DFS Cycle Detection: Directed vs Undirected Graphs
========================

1. Undirected Graphs:

- Edges go both ways. Example: 0-1 means 0->1 and 1->0.
- Problem with 3-state array (0=unvisited, 1=visiting, 2=visited):
    - DFS from 0 to 1 marks 1 as visiting (1).
    - DFS back from 1 to 0 sees 0 as visiting (1) → falsely detects a cycle.
    - This happens because 0 is actually the parent, not a real cycle.
- Solution:
    - Use 2 states: visited / not visited.
    - Pass a parent parameter in DFS to ignore the edge leading back to the parent.
- Key idea: 3 states unnecessary; parent check handles cycles.

Example adjacency list:

0 -> 1,2
1 -> 0,3
2 -> 0,3
3 -> 1,2,4
4 -> 3

DFS path visiting all nodes: 0 → 1 → 3 → 2 → 4
Cycle edges detected: 2->0

---

2. Directed Graphs:

- Edges have one direction only.
- 3 states are required: 0 = unvisited, 1 = visiting (in recursion stack), 2 = visited.
- Example adjacency list:

0 -> 1,2
1 -> 3
2 -> 3
3 -> 4
4 -> 1  // creates a cycle

- DFS traversal:
    1. Start 0 → visiting
    2. Go to 1 → visiting
    3. Go to 3 → visiting
    4. Go to 4 → visiting
    5. Go to 1 → already visiting → cycle detected ✅
- States explanation:
    - 1 (visiting) → node is in current recursion stack → used to detect cycles.
    - 2 (visited) → node fully processed → safe to ignore.
    - 0 (unvisited) → not yet explored.

- Returning immediately on detecting a cycle stops DFS; continuing allows building full traversal / topological order.

---

3. Key Differences:

Property               | Undirected Graph                  | Directed Graph
-----------------------|---------------------------------|--------------------------------
Edge direction          | Both ways                        | One way
Parent needed?          | Yes (to avoid false cycle)       | No
States needed           | 2 (visited/unvisited)           | 3 (unvisited, visiting, visited)
Cycle detection         | Check visited + parent           | Check visiting state (1)
DFS stack behavior      | Can revisit parent safely        | Visiting state detects cycles

---

Conclusion:

- Undirected graph: 3 states → false positives because edges go back to parent. Use 2 states + parent.
- Directed graph: 3 states → correctly detects cycles in recursion stack.
